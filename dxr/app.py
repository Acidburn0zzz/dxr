from functools import partial
from logging import StreamHandler
from os.path import isdir, isfile, join, basename
from sys import stderr
from time import time
from urllib import quote_plus

from flask import (Blueprint, Flask, send_from_directory, current_app,
                   send_file, request, redirect, jsonify, render_template,
                   url_for)
from pyelasticsearch import ElasticSearch
from werkzeug.exceptions import NotFound

from dxr.build import linked_pathname
from dxr.mime import icon
from dxr.plugins import FILE
from dxr.query import Query, filter_menu_items
from dxr.utils import non_negative_int, search_url, TEMPLATE_DIR, decode_es_datetime  # Make sure we load trilite before possibly importing the wrong version of sqlite3.


# Look in the 'dxr' package for static files, etc.:
dxr_blueprint = Blueprint('dxr_blueprint',
                          'dxr',
                          template_folder=TEMPLATE_DIR,
                          # static_folder seems to register a "static" route
                          # with the blueprint so the url_prefix (set later)
                          # takes effect for static files when found through
                          # url_for('static', ...).
                          static_folder='static')


def make_app(instance_path):
    """Return a DXR application which looks in the given folder for
    configuration.

    Also set up the static and template folder.

    """
    app = Flask('dxr', instance_path=instance_path)

    # Load the special config file generated by dxr-build:
    app.config.from_pyfile(join(app.instance_path, 'config.py'))

    app.register_blueprint(dxr_blueprint, url_prefix=app.config['WWW_ROOT'])

    # Log to Apache's error log in production:
    app.logger.addHandler(StreamHandler(stderr))

    # Make an ES connection pool shared among all threads:
    app.es = ElasticSearch(app.config['ES_HOSTS'])

    return app


@dxr_blueprint.route('/')
def index():
    config = current_app.config
    return redirect(url_for('.browse', tree=config['DEFAULT_TREE']))


@dxr_blueprint.route('/<tree>/search')
def search(tree):
    """Search by regex, caller, superclass, or whatever."""
    # TODO: This function still does too much.
    querystring = request.values

    offset = non_negative_int(querystring.get('offset'), 0)
    limit = min(non_negative_int(querystring.get('limit'), 100), 1000)

    config = current_app.config
    www_root = config['WWW_ROOT']
    trees = config['TREES']

    # Arguments for the template:
    arguments = {
        # Common template variables
        'wwwroot': www_root,
        'generated_date': config['GENERATED_DATE']}

    error = ''
    status_code = None

    if tree in trees:
        arguments['tree'] = tree

        # Parse the search query:
        qtext = querystring.get('q', '')
        is_case_sensitive = querystring.get('case') == 'true'
        q = Query(partial(current_app.es.search,
                          index=config['ES_ALIASES'][tree]),
                  qtext,
                  is_case_sensitive=is_case_sensitive)

        # Try for a direct result:
        if querystring.get('redirect') == 'true':
            result = q.direct_result()
            if result:
                path, line = result
                # TODO: Does this escape qtext properly?
                return redirect(
                    '%s/%s/source/%s?from=%s%s#%i' %
                    (www_root,
                     tree,
                     path,
                     qtext,
                     '&case=true' if is_case_sensitive else '',
                     line))

        # Return multiple results:
        template = 'search.html'
        arguments['query'] = qtext
        arguments['search_url'] = url_for('.search',
                                          tree=arguments['tree'],
                                          q=qtext,
                                          redirect='false')
        arguments['results'] = list(q.results(offset, limit))
        arguments['offset'] = offset
        arguments['limit'] = limit
        arguments['is_case_sensitive'] = is_case_sensitive
        arguments['tree_tuples'] = [
                (t,
                 url_for('.search',
                         tree=t,
                         q=qtext,
                         **({'case': 'true'} if is_case_sensitive else {})),
                 description)
                for t, description in trees.iteritems()]
    else:
        arguments['tree'] = trees.keys()[0]
        error = "Tree '%s' is not a valid tree." % tree
        status_code = 404

    if error:
        arguments['error'] = error

    if querystring.get('format') == 'json':
        if error:
            # Return a non-OK code so the live search doesn't try to replace
            # the results with our empty ones:
            return jsonify(arguments), status_code or 500

        # Tuples are encoded as lists in JSON, and these are not real
        # easy to unpack or read in Javascript. So for ease of use, we
        # convert to dictionaries.
        arguments['results'] = [
            {'icon': icon,
             'path': path,
             'lines': [{'line_number': nb, 'line': l} for nb, l in lines]}
                for icon, path, lines in arguments['results']]
        return jsonify(arguments)

    if error:
        return render_template('error.html', **arguments), status_code or 500
    else:
        arguments['filters'] = filter_menu_items(config['FILTER_LANGUAGE'])
        return render_template('search.html', **arguments)


@dxr_blueprint.route('/<tree>/source/')
@dxr_blueprint.route('/<tree>/source/<path:path>')
def browse(tree, path=''):
    """Show a directory listing or a single file from one of the trees."""
    tree_folder = _tree_folder(tree)
    try:
        return send_from_directory(tree_folder, _html_file_path(tree_folder, path))
    except NotFound as exc:
        config = current_app.config

        # It's a folder (or nonexistent), not a file. Serve it out of ES.
        # Eventually, we want everything to be in ES.
        files_and_folders = [x['_source'] for x in current_app.es.search(
            {
                'query': {
                    'filtered': {
                        'query': {
                            'match_all': {}
                        },
                        'filter': {
                            'term': {'folder': path}
                        }
                    }
                },
                'sort': [{'is_folder': 'desc'}, 'name']
            },
            index=config['ES_ALIASES'][tree],
            doc_type=FILE,
            size=10000)['hits']['hits']]

        if not files_and_folders:
            raise NotFound

        return render_template(
            'folder.html',
            # Common template variables:
            wwwroot=config['WWW_ROOT'],
            tree=tree,
            tree_tuples=[
                (t_name,
                 url_for('.parallel', tree=t_name, path=path),
                 t_description)
                for t_name, t_description in config['TREES'].iteritems()],
            generated_date=config['GENERATED_DATE'],
            paths_and_names=linked_pathname(path, tree),
            filters=filter_menu_items(config['FILTER_LANGUAGE']),
            # Autofocus only at the root of each tree:
            should_autofocus_query=path == '',

            # Folder template variables:
            name=basename(path) or tree,
            path=path,
            files_and_folders=[
                ('folder' if f['is_folder'] else icon(f['name']),
                 f['name'],
                 decode_es_datetime(f['modified']) if 'modified' in f else None,
                 f.get('size'),
                 url_for('.browse', tree=tree, path=f['path']))
                for f in files_and_folders])


@dxr_blueprint.route('/<tree>/')
@dxr_blueprint.route('/<tree>')
def tree_root(tree):
    """Redirect requests for the tree root instead of giving 404s."""
    return redirect(tree + '/source/')


@dxr_blueprint.route('/<tree>/parallel/')
@dxr_blueprint.route('/<tree>/parallel/<path:path>')
def parallel(tree, path=''):
    """If a file or dir parallel to the given path exists in the given tree,
    redirect to it. Otherwise, redirect to the root of the given tree.

    We do this with the future in mind, in which pages may be rendered at
    request time. To make that fast, we wouldn't want to query every one of 50
    other trees, when drawing the Switch Tree menu, to see if a parallel file
    or folder exists. So we use this controller to put off the querying until
    the user actually choose another tree.

    """
    tree_folder = _tree_folder(tree)
    disk_path = _html_file_path(tree_folder, path)
    www_root = current_app.config['WWW_ROOT']
    if isfile(join(tree_folder, disk_path)):
        return redirect('{root}/{tree}/source/{path}'.format(
            root=www_root,
            tree=tree,
            path=path))
    else:
        return redirect('{root}/{tree}/source/'.format(
            root=www_root,
            tree=tree))


def _tree_folder(tree):
    """Return the on-disk path to the root of the given tree's folder in the
    instance."""
    return join(current_app.instance_path, 'trees', tree)


def _html_file_path(tree_folder, url_path):
    """Return the on-disk path, relative to the tree folder, of the HTML file
    that should be served when a certain path is browsed to.

    :arg tree_folder: The on-disk path to the tree's folder in the instance
    :arg url_path: The URL path browsed to, rooted just inside the tree

    If you provide a path to a non-existent file or folder, I will happily
    return a path which has no corresponding FS entity.

    """
    if isdir(join(tree_folder, url_path)):
        # It's a bare directory. Add the index file to the end:
        return join(url_path, current_app.config['DIRECTORY_INDEX'])
    else:
        # It's a file. Add the .html extension:
        return url_path + '.html'
